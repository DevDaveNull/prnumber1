name: Build check

on:
  push:
    branches: [ "**" ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile-and-wait:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Ensure repository is PUBLIC
        if: ${{ github.event.repository.private }}
        run: |
          echo "❌ Этот форк приватный. Для автопроверки сделайте репозиторий PUBLIC (или дайте преподавателю доступ)."
          exit 1

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Compile sources
        id: compile
        run: |
          FILES=$(find src/main/java -name "*.java")
          if [ -z "$FILES" ]; then
            echo "❌ В каталоге src/main/java не найдены .java файлы."
            exit 1
          fi
          javac $FILES
          echo "✅ Код скомпилирован."

      # Пытаемся запустить приватный грейдер. Даём подробную диагностику и
      # выставляем флаг sent=true только при успешном 204.
      - name: Trigger private grading in java-course-grading
        if: ${{ success() && steps.compile.outcome == 'success' }}
        id: trigger
        env:
          GH_TOKEN: ${{ secrets.GRADING_TRIGGER_PAT }}   # PAT (classic): public_repo (или repo для приватного грейдера)
          OWNER:   ВАШ_АККАУНТ_ИЛИ_ОРГ                   # ← замените на владельца грейдера
          GRADER:  java-course-grading                   # ← при необходимости
        shell: bash
        run: |
          set -e
          SENT=false

          if [ -z "$GH_TOKEN" ]; then
            echo "::notice::GRADING_TRIGGER_PAT недоступен в этом репозитории (форки студентов не видят org secrets)."
            echo "::notice::Приватная проверка запустится через PR в основной репозиторий преподавателя или вручную."
            echo "sent=$SENT" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Авторизуемся токеном…"
          gh api user -q '.login' || { echo "::error::Не удалось авторизоваться GH_TOKEN'ом"; exit 1; }

          echo "Проверяем доступ к ${OWNER}/${GRADER}…"
          gh api -i "repos/${OWNER}/${GRADER}" >/dev/null

          echo "Отправляем repository_dispatch (repo=${{ github.repository }}, branch=${{ github.ref_name }}, sha=${{ github.sha }})…"
          # Успех = HTTP/1.1 204 No Content
          RESP=$(gh api -i "repos/${OWNER}/${GRADER}/dispatches" \
            -f event_type=grade-request \
            -f client_payload:="{\"repo\":\"${{ github.repository }}\",\"branch\":\"${{ github.ref_name }}\",\"sha\":\"${{ github.sha }}\"}" \
            2>&1 || true)

          echo "$RESP"

          if echo "$RESP" | grep -qE '^HTTP/1\.1 204 '; then
            SENT=true
            echo "✅ repository_dispatch отправлен."
          else
            echo "::warning::Не удалось отправить repository_dispatch. См. вывод выше (возможны 401/403/404: нет прав у PAT, SSO не авторизован, неверный OWNER/GRADER)."
          fi

          echo "sent=$SENT" >> "$GITHUB_OUTPUT"

      # jq ставим только если действительно ждём комментарий от грейдера
      - name: Ensure jq is available
        if: ${{ steps.trigger.outputs.sent == 'true' }}
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

      - name: Wait for private grading comment (print full log)
        if: ${{ steps.trigger.outputs.sent == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          SHA:  ${{ github.sha }}
          GRADER_PREFIX: "Grading result:"
          MAX_TRIES: "60"     # ~30 минут ожидания
          SLEEP_SEC: "30"
        shell: bash
        run: |
          echo "Ожидаем комментарии от автотестов для $REPO@$SHA …"
          i=0
          HEADER=""

          while [ $i -lt $MAX_TRIES ]; do
            RESP=$(gh api -X GET "repos/$REPO/commits/$SHA/comments" 2>/dev/null || true)
            HEADER=$(echo "$RESP" \
              | jq -r 'sort_by(.created_at) | reverse | .[] | .body
                       | select(startswith(env.GRADER_PREFIX))' \
              | head -n1)
            if [ -n "$HEADER" ] && [ "$HEADER" != "null" ]; then
              break
            fi
            i=$((i+1))
            echo "… пока нет (попытка $i/$MAX_TRIES). Спим $SLEEP_SEC сек."
            sleep "$SLEEP_SEC"
          done

          if [ -z "$HEADER" ] || [ "$HEADER" = "null" ]; then
            echo "::warning::Не дождались приватной проверки. Загляните позже в комментарии к коммиту или в общий отчёт преподавателя."
            exit 0
          fi

          echo
          echo "━━━━━━━━━━ РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ ТЕСТОВ ━━━━━━━━━━"
          printf "%s\n" "$HEADER"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo

          # собираем части лога "Grading log (part i/N):" по порядку
          RESP_ALL=$(gh api -X GET "repos/$REPO/commits/$SHA/comments" 2>/dev/null || true)
          parts=$(echo "$RESP_ALL" | jq -r '
            sort_by(.created_at) | .[] | .body
            | select(startswith("Grading log (part "))
            | capture("^Grading log \\(part (?<i>[0-9]+)\\/(?<n>[0-9]+)\\):\\n(?:\\n)?```[^\\n]*\\n(?<text>(.|\\n|\\r)*?)\\n```$")
            | @base64
          ')

          if [ -z "$parts" ]; then
            echo "::notice::Дополнительные части лога не найдены."
          else
            N=$(echo "$parts" | while read -r line; do echo "$line" | base64 --decode | jq -r '.n'; done | sort -nr | head -n1)
            echo "▼ Лог из приватной проверки (частей: ${N:-?})"
            for idx in $(seq 1 ${N:-1}); do
              chunk=$(echo "$parts" | while read -r line; do
                        obj=$(echo "$line" | base64 --decode)
                        ii=$(echo "$obj" | jq -r '.i')
                        if [ "$ii" = "$idx" ]; then
                          echo "$obj" | jq -r '.text'
                          break
                        fi
                      done)
              [ -n "$chunk" ] && printf "%s\n" "$chunk"
            done
            echo "▲ Конец лога"
          fi

          FIRST_LINE=$(printf "%s\n" "$HEADER" | head -n1)
          if echo "$FIRST_LINE" | grep -qiE '^Grading result:\s*OK\b'; then
            echo "✅ Приватные тесты пройдены."
            exit 0
          else
            echo "❌ Приватные тесты НЕ пройдены."
            exit 1
          fi
