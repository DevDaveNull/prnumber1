name: Build check

on:
  push:
    branches: [ "**" ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile-and-wait:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Ensure repository is PUBLIC
        if: ${{ github.event.repository.private }}
        run: |
          echo "❌ Этот форк приватный. Для автопроверки сделайте репозиторий PUBLIC (или дайте преподавателю доступ)."
          exit 1

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Compile sources
        id: compile
        run: |
          FILES=$(find src/main/java -name "*.java")
          if [ -z "$FILES" ]; then
            echo "❌ В каталоге src/main/java не найдены .java файлы."
            exit 1
          fi
          javac $FILES
          echo "✅ Код скомпилирован."

      # Триггер приватного грейдера без heredoc — через gh api
      - name: Trigger private grading in java-course-grading
        if: ${{ success() && steps.compile.outcome == 'success' }}
        env:
          GH_TOKEN: ${{ secrets.GRADING_TRIGGER_PAT }}   # орг-секрет с PAT
        run: |
          if [ -z "$GH_TOKEN" ]; then
            echo "::warning::Нет секрета GRADING_TRIGGER_PAT — пропускаем автозапуск приватной проверки."
            exit 0
          fi
          OWNER="ВАШ_АККАУНТ_ИЛИ_ОРГ"
          GRADER_REPO="java-course-grading"
          echo "Отправляем repository_dispatch в ${OWNER}/${GRADER_REPO}…"
          gh api repos/${OWNER}/${GRADER_REPO}/dispatches \
            -f event_type=grade-request \
            -f client_payload:="{\"repo\":\"${{ github.repository }}\",\"branch\":\"${{ github.ref_name }}\",\"sha\":\"${{ github.sha }}\"}"

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

      - name: Wait for private grading comment (print full log)
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          SHA:  ${{ github.sha }}
          GRADER_PREFIX: "Grading result:"
          MAX_TRIES: "60"     # ~30 минут ожидания
          SLEEP_SEC: "30"
        shell: bash
        run: |
          echo "Ожидаем комментарии от автотестов для $REPO@$SHA …"
          i=0
          HEADER=""

          # ждём заголовок "Grading result:"
          while [ $i -lt $MAX_TRIES ]; do
            RESP=$(gh api -X GET "repos/$REPO/commits/$SHA/comments" 2>/dev/null || true)
            HEADER=$(echo "$RESP" \
              | jq -r 'sort_by(.created_at) | reverse | .[] | .body
                       | select(startswith(env.GRADER_PREFIX))' \
              | head -n1)
            if [ -n "$HEADER" ] && [ "$HEADER" != "null" ]; then
              break
            fi
            i=$((i+1))
            echo "… пока нет (попытка $i/$MAX_TRIES). Спим $SLEEP_SEC сек."
            sleep "$SLEEP_SEC"
          done

          if [ -z "$HEADER" ] || [ "$HEADER" = "null" ]; then
            echo "::warning::Не дождались приватной проверки. Загляните позже в комментарии к коммиту или в общий отчёт преподавателя."
            exit 0
          fi

          echo
          echo "━━━━━━━━━━ РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ ТЕСТОВ ━━━━━━━━━━"
          printf "%s\n" "$HEADER"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo

          # собираем все части лога "Grading log (part i/N):" и печатаем по порядку
          RESP_ALL=$(gh api -X GET "repos/$REPO/commits/$SHA/comments" 2>/dev/null || true)
          parts=$(echo "$RESP_ALL" | jq -r '
            sort_by(.created_at) | .[] | .body
            | select(startswith("Grading log (part "))
            | capture("^Grading log \\(part (?<i>[0-9]+)\\/(?<n>[0-9]+)\\):\\n(?:\\n)?```[^\\n]*\\n(?<text>(.|\\n|\\r)*?)\\n```$")
            | @base64
          ')

          if [ -z "$parts" ]; then
            echo "::notice::Дополнительные части лога не найдены."
          else
            N=$(echo "$parts" | while read -r line; do echo "$line" | base64 --decode | jq -r '.n'; done | sort -nr | head -n1)
            echo "▼ Лог из приватной проверки (частей: ${N:-?})"
            for idx in $(seq 1 ${N:-1}); do
              chunk=$(echo "$parts" | while read -r line; do
                        obj=$(echo "$line" | base64 --decode)
                        ii=$(echo "$obj" | jq -r '.i')
                        if [ "$ii" = "$idx" ]; then
                          echo "$obj" | jq -r '.text'
                          break
                        fi
                      done)
              [ -n "$chunk" ] && printf "%s\n" "$chunk"
            done
            echo "▲ Конец лога"
          fi

          FIRST_LINE=$(printf "%s\n" "$HEADER" | head -n1)
          if echo "$FIRST_LINE" | grep -qiE '^Grading result:\s*OK\b'; then
            echo "✅ Приватные тесты пройдены."
            exit 0
          else
            echo "❌ Приватные тесты НЕ пройдены."
            exit 1
          fi
