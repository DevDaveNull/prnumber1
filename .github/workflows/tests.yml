name: Build check

on:
  push:
    branches: [ "**" ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile-and-trigger:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Ensure repository is PUBLIC
        if: ${{ github.event.repository.private }}
        run: |
          echo "‚ùå –≠—Ç–æ—Ç —Ñ–æ—Ä–∫ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π. –î–ª—è –∞–≤—Ç–æ–ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–¥–µ–ª–∞–π—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π PUBLIC (–∏–ª–∏ –¥–∞–π—Ç–µ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—é –¥–æ—Å—Ç—É–ø)."
          exit 1

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Compile sources
        id: compile
        run: |
          FILES=$(find src/main/java -name "*.java")
          if [ -z "$FILES" ]; then
            echo "‚ùå –í –∫–∞—Ç–∞–ª–æ–≥–µ src/main/java –Ω–µ –Ω–∞–π–¥–µ–Ω—ã .java —Ñ–∞–π–ª—ã."
            exit 1
          fi
          javac $FILES
          echo "‚úÖ –ö–æ–¥ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω."

      - name: Trigger private grading in java-course-grading
        if: ${{ success() && steps.compile.outcome == 'success' }}
        env:
          TRIGGER_TOKEN: ${{ secrets.GRADING_TRIGGER_PAT }}   # —Å–µ–∫—Ä–µ—Ç –∏–∑ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
        run: |
          if [ -z "$TRIGGER_TOKEN" ]; then
            echo "::warning::–ù–µ—Ç —Å–µ–∫—Ä–µ—Ç–∞ GRADING_TRIGGER_PAT ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫ –ø—Ä–∏–≤–∞—Ç–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏."
            exit 0
          fi

          OWNER="–í–ê–®_–ê–ö–ö–ê–£–ù–¢_–ò–õ–ò_–û–†–ì"        # –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞ java-course-grading
          GRADER_REPO="java-course-grading"  # –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è —Å –ø—Ä–∏–≤–∞—Ç–Ω—ã–º–∏ —Ç–µ—Å—Ç–∞–º–∏

          echo "üì® –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –≤ $OWNER/$GRADER_REPO ‚Ä¶"
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token ${TRIGGER_TOKEN}" \
            https://api.github.com/repos/${OWNER}/${GRADER_REPO}/dispatches \
            -d @- <<JSON
          {
            "event_type": "grade-request",
            "client_payload": {
              "repo": "${{ github.repository }}",
              "branch": "${{ github.ref_name }}",
              "sha": "${{ github.sha }}"
            }
          }
JSON

      # jq –æ–±—ã—á–Ω–æ –µ—Å—Ç—å –Ω–∞ —Ä–∞–Ω–Ω–µ—Ä–µ, –Ω–æ –ø–æ–¥—Å—Ç—Ä–∞—Ö—É–µ–º—Å—è
      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

      - name: Wait for private grading comment (print full log)
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          SHA:  ${{ github.sha }}
          GRADER_PREFIX: "Grading result:"
          MAX_TRIES: "60"     # ~30 –º–∏–Ω—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è
          SLEEP_SEC: "30"
        shell: bash
        run: |
          echo "–û–∂–∏–¥–∞–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ—Ç –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –≥—Ä–µ–π–¥–µ—Ä–∞ –¥–ª—è $REPO@$SHA ‚Ä¶"
          i=0
          BODY=""

          while [ $i -lt $MAX_TRIES ]; do
            RESP=$(gh api -X GET "repos/$REPO/commits/$SHA/comments" 2>/dev/null || true)
            BODY=$(echo "$RESP" \
              | jq -r 'sort_by(.created_at) | reverse | .[] | .body
                       | select(startswith(env.GRADER_PREFIX))' \
              | head -n1)

            if [ -n "$BODY" ] && [ "$BODY" != "null" ]; then
              break
            fi

            i=$((i+1))
            echo "‚Ä¶ –ø–æ–∫–∞ –Ω–µ—Ç (–ø–æ–ø—ã—Ç–∫–∞ $i/$MAX_TRIES). –°–ø–∏–º $SLEEP_SEC —Å–µ–∫."
            sleep "$SLEEP_SEC"
          done

          if [ -z "$BODY" ] || [ "$BODY" = "null" ]; then
            echo "::warning::–ù–µ –¥–æ–∂–¥–∞–ª–∏—Å—å –ø—Ä–∏–≤–∞—Ç–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏. –ó–∞–≥–ª—è–Ω–∏—Ç–µ –ø–æ–∑–∂–µ –≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∫ –∫–æ–º–º–∏—Ç—É –∏–ª–∏ –≤ –æ–±—â–∏–π –æ—Ç—á—ë—Ç –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è."
            exit 0
          fi

          echo
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ –†–ï–ó–£–õ–¨–¢–ê–¢ –ü–†–ò–í–ê–¢–ù–´–• –¢–ï–°–¢–û–í ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          printf "%s\n" "$BODY"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo

          LOG=$(printf "%s\n" "$BODY" | awk 'BEGIN{p=0} /^```/ {p=!p; next} p==1 {print}')
          if [ -n "$LOG" ]; then
            echo "‚ñº –õ–æ–≥ –∏–∑ –ø—Ä–∏–≤–∞—Ç–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ (–∫–∞–∫ –µ—Å—Ç—å)"
            printf "%s\n" "$LOG"
            echo "‚ñ≤ –ö–æ–Ω–µ—Ü –ª–æ–≥–∞"
          fi

          FIRST_LINE=$(printf "%s\n" "$BODY" | head -n1)
          if echo "$FIRST_LINE" | grep -qiE '^Grading result:\s*OK\b'; then
            echo "‚úÖ –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã."
            exit 0
          else
            echo "‚ùå –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ —Ç–µ—Å—Ç—ã –ù–ï –ø—Ä–æ–π–¥–µ–Ω—ã."
            exit 1
          fi
